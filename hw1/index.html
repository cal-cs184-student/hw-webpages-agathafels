<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184 Spring 2026 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Agatha Santoso & Jeremiah Harsojo</div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-jerjit">https://github.com/cal-cs184-student/hw1-rasterizer-jerjit</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		<p>		We built a whole mini rendering pipeline, from triangle rasterization to supersampling for antialiasing, 
			geometric transformations, barycentric interpolation, texture mapping, and mipmap level sampling. In each section, 
			we learned how the continuous representation of geometry and textures is mapped to the discrete pixel representation on the screen.
			<br><br>
			The most interesting part was observing how sampling impacts image quality. Supersampling demonstrated how aliasing happens and 
			how averaging subpixel samples resulted in smoother edges. Barycentric coordinates made triangle interpolation easy, especially 
			when interpolating smoothly between colors and texture coordinates. Texture mapping and mipmapping further reinforced the idea that 
			image rendering is a resampling process, where the choice of sampling and filtering technique has a huge effect on the final image quality.
		</p>


		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<h3>How we rasterize triangles?</h3>
		<p>
		Rasterizing itself means converting a geometric shape into screen pixels. To rasterize a triangle, we start with the three 
		vertex coordinates (x0, y0), (x1, y1), and (x2, y2) that define the triangle.
		</p>
		<p>
		First, we compute the bounding box by finding the minimum and maximum x and y values among the three vertices. 
		Then we round these values using floor and ceil to get integer pixel boundaries. We also make sure these values stay within 
		the screen boundaries to prevent drawing outside the framebuffer.
		Next, we iterate through every pixel inside the bounding box. For each pixel, we sample at its center (x + 0.5, y + 0.5). 
		We determine whether this center lies inside or outside the triangle by computing the three edge tests using the cross product. 
		If the sample point lies on the same side of all three edges (all positive or all negative), then it is inside the triangle, 
		and we fill it with color by calling fill_pixel. Then, we repeat this process for every pixel in the bounding box to fully rasterize the triangle on the screen.
		</p>

		<h3>Why our algorithm is no worse than checking each sample in the bounding box?</h3>
		<p>
		The algorithm we wrote finds the smallest rectangle that contains the triangle (the bounding box) and checks the pixels inside 
		that rectangle. For each pixel, it simply checks whether the pixel center is inside the triangle. 
		Therefore, the runtime is proportional to the size of the bounding box and is not worse than checking every sample within it.
		</p>

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="q1_screenshot.png" width="500px"/>
				  <figcaption>Zoomed-in view</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		<p>Our supersampling algorithm is similar to Task 1, except that instead of rendering to the framebuffer, we render to a sample buffer. We break each pixel down into smaller subpixels based on the sample rate (4 samples means 2x2 inside each pixel). This sample is then written into the sample buffer. Then, for each subpixel, we check if it's inside the triangle and store the color in the sample buffer.
			<br><br>Once all the triangles have been rasterized, we calculate the average color of all the subpixels inside each pixel and render it to the framebuffer. We also altered the pipeline to resize the sample buffer whenever the sample rate changes.
			<br></br>The supersampling technique can be used to reduce jaggies because, instead of determining that a pixel is entirely inside or outside the triangle, we determine partial coverage. When we calculate the average color of these subpixels, it makes the edges smoother.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td colspan="2" style="text-align: center; padding-bottom: 20px;">
						<img src="q2_screenshot_no_sampling.png" width="500px"/>
						<figcaption>Sample Rate 1</figcaption>
					</td>
				</tr>

				<tr>
					<td style="text-align: center;">
						<img src="q2_screenshot_4x_sampling.png" width="500px"/>
						<figcaption>Sample Rate 4</figcaption>
					</td>

					<td style="text-align: center;">
						<img src="q2_screenshot_16x_sampling.png" width="500px"/>
						<figcaption>Sample Rate 16</figcaption>
					</td>
				</tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		<p>We wanted to make a visual effect of the cubeman taking off its head because we want 
			the cubeman to do something unique and fun. We also changed its color to be more unique. 
			To achieve this, we adjusted the SVG transformation groups for the arms. 
			Specifically, we rotated the upper arm segments upward at the shoulder and then applied 
			additional rotation and translation to the outer arm blocks to make the elbow bending. 
			We also scale the head bigger for better proportion.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="q3_cubeman_headoff.png" width="500px"/>
						<figcaption>Cubeman Head Off</figcaption>
					</td>
				</tr>
			</table>
		</div>
		

		<h2>Task 4: Barycentric coordinates</h2>
		<p>Barycentric coordinates describe a point inside a triangle as a combination of the triangles' three vertices. 
			The three values (alpha, beta, gamma) tell us how close the point is to each vertex. 
			These three values always add up to 1.
		</p>
		<p>Here, each vertex of the triangle has a different color: red, green, and blue. 
			For every sample point inside the triangle, we compute alpha, beta, and gamma. 
			If alpha is larger, the point is closer to the vertex with the red color, so the color appears more red. 
			If beta or gamma is larger, the color shifts toward green or blue.
		</p>
		<p>In the center of the triangle, the three values are similar so the colors blend smoothly. 
			Using this method, we create the smooth color wheel effect.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="q4_screenshot_colorwheel.png" width="500px"/>
						<figcaption>Barycentric Coordinates</figcaption>
					</td>
				</tr>
			</table>
		</div>


		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		<p>
		Pixel sampling is deciding what color to take from a texture image when we map it to a triangle. 
		For each sample inside the triangle, I computed the barycentric coordinates and used it to interpolate 
		the texture coordinates (u,v). I then create a <code>SampleParams</code> struct 
		and call <code>tex.sample(sp)</code> to get the texture color. In <code>Texture::sample()</code>, 
		the sampling method is selected based on <code>sp.psm</code>, which switches between nearest 
		and bilinear sampling.
		</p>

		<p>
		In nearest sampling, we convert the UV coordinate into a texel index using 
		<code>floor(u * width)</code> and <code>floor(v * height)</code>, clamp it to valid bounds, 
		and return that single texel color. This method is simple and fast, but when the texture 
		is magnified it can look blocky because each sample snaps to one texel without blending. 
		From the screenshots, nearest sampling at 1 sample per pixel shows very clear square texel 
		boundaries and abrupt color changes. Increasing the sample rate to 16 smooths the triangle 
		edges, but the texture itself still looks blocky because nearest sampling does not interpolate 
		between texels.
		</p>

		<p>
		In bilinear sampling, I find the four surrounding texels and use the fractional offsets 
		(s, t) to interpolate between them (two horizontal lerps followed by one vertical lerp). 
		This blends neighboring texels, producing smoother transitions and reducing visible 
		block boundaries, though it can appear slightly blurrier when magnified. From the comparison, 
		bilinear sampling at 1 sample per pixel already looks smoother than nearest because color 
		transitions are gradual instead of abrupt. When using bilinear with 16 samples per pixel, 
		both the triangle edges and the texture transitions appear smoother, producing the best overall result. 
		The difference between nearest and bilinear is most noticeable when the texture is magnified 
		or when UV coordinates fall between texel centers, because nearest sampling causes sharp jumps 
		between texels while bilinear blends neighboring texels.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="padding: 10px;">
						<img src="q5_bilinear_samplerate_1.png" width="500px"/>
						<figcaption>Bilinear Sample Rate 1</figcaption>
					</td>
					<td style="padding: 10px;">
						<img src="q5_bilinear_samplerate_16.png" width="500px"/>
						<figcaption>Bilinear Sample Rate 16</figcaption>
					</td>
				</tr>
				<tr>
					<td style="padding: 10px;">
						<img src="q5_nearest_samplerate_1.png" width="500px"/>
						<figcaption>Nearest Sample Rate 1</figcaption>
					</td>
					<td style="padding: 10px;">
						<img src="q5_nearest_samplerate_16.png" width="500px"/>
						<figcaption>Nearest Sample Rate 16</figcaption>
					</td>
				</tr>
			</table>
		</div>


		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>